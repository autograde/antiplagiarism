\documentclass[12pt]{article}

\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{floatrow}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{url}

\title{Anti-plagiarism Project}
\date{2015-10-21}
\author{Eric Scott Freeman}

\begin{document}
	\pagenumbering{gobble}
	\maketitle
	\newpage
	\tableofcontents
	\newpage
	\pagenumbering{arabic}
	\section{Introduction}
		The University of Stavanger uses an application called Autograder, written by Heine Furubotten, to automatically grade students' programming assignments. Autograder works with Github. Whenever a student pushes their code to Github, Autograder will pull a copy of the code and run a series of tests on it. Autograder does not currently have support for plagiarism detection. The goal of this project is to integrate a few anti-plagiarism tools into Autograder, thereby helping the professors save time.
		
	\section{Related Work}
		Unfortunately software plagiarism is a problem both in the classroom and in the workplace. A number of applications have been created to help detect this problem. While these tools can detect similarities in programs, the flagged files must still be manually examined to determine whether or not code was plagiarized.
		
		There are several different general techniques that are used to look for plagiarism. The tools analyzed in this project used either fingerprinting or stylometry.
	
		\subsection{Fingerprinting}
			Several tools use a technique called fingerprinting to detect plagiarism. In fingerprinting algorithms, hashes of $n$-grams, substrings that are $n$ characters, are saved and compared to help find plagiarism. Not all hashes are stored due to the large number that would be produced. 
		
			\subsubsection{Winnowing}
				Moss uses a technique called winnowing to select which hashes to save \cite{schleimer+wilkerson+aiken}. In the winnowing algorithm, a window, selection of contiguous hashes, is used to help select which hashes to save. The smallest hash from a window is saved, and then the window moves one hash over. The smallest hash from the next window is often the smallest hash from the previous window. If so it is not saved again. Figure \ref{fig:winnowing1} shows an example of how winnowing works. The orange box represents the shifting window. The green box shows whenever a new hash is saved.
				
				\begin{figure}[h!]
					\includegraphics[scale=0.75]{Winnowing.png}
					\caption{Winnowing.}
					\label{fig:winnowing1}
				\end{figure}
			
			\subsubsection{Running-Karp-Rabin Greedy-String-Tiling}
				JPlag uses Running-Karp-Rabin Greedy-String-Tiling (RKS-GST) to compare hashes of code in plagiarism detection \cite{prechelt+malpohl+philippsen}. RKS-GST was originally used in YAP3, another plagiarism detection tool. In RKS-GST, the Greedy String half of the algorithm forms pairs of substrings, each from a different string. Then the Karp-Rabin half of the algorithm hashes each substring in the pair \cite{wise}. This is done to help detect code reordering.
		
		\subsection{Stylometry}
			Another approach is to use code stylometry, which analyzes the style of writing or coding.
			
			\subsubsection{Abstract Syntax Trees}
				Caliskan-Islam, et al. use abstract syntax trees (ASTs) to compare the styles of authors \cite{caliskan-islam+harang+liu}. Things that are easily changed in code, such as variable names, become leaves in the AST, while the structure of the tree is harder to change \cite{caliskan-islam+harang+liu}. Figure \ref{fig:ast} shows an abstract syntax tree of the code in Figure \ref{fig:astcode}. Note how the leaves, or circular nodes, in Figure \ref{fig:ast} are variable names, constants, and a function name.
				
				Michal Bohusl√°vek's dupl application uses ASTs to find similarities in code \cite{bohuslave}. It looks for any copies of code, not just plagiarism. So if a piece of code is duplicated even in the same file, it will test positive.
			
				\begin{figure}
					\begin{floatrow}
						\ffigbox{\includegraphics[scale=0.1]{AST.png}}{\caption{Abstract syntax tree.}\label{fig:ast}}	\ffigbox{\includegraphics[scale=0.5]{ASTcode.png}}{\caption{Example code.}\label{fig:astcode}}
					\end{floatrow}
				\end{figure}
		
		\subsection{Supported Languages}
			Fingerprinting and string comparison techniques can be used to analyze source code written in languages other than their officially supported languages. Moss can analyze Go code, even though it is not technically supported. Since ASTs need to parse the code, applications which use them are stricter on which languages they can analyze. For example dupl only supports code written in Go. Table \ref{tab:languageSupport} shows the languages officially supported by several anti-plagiarism tools.
		
			\begin{table}[h!]
				\begin{center}
					\caption{Officially supported languages by various tools}
					\label{tab:languageSupport}
					\begin{tabular}{ccccccccccccccc}
						\toprule
						Tool & Java & Go & C & C\verb!++! & C\verb!#! & Python & Perl & others\\
						\midrule
						Moss & \checkmark & & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
						JPlag & \checkmark & & \checkmark & \checkmark & \checkmark & & & \checkmark\\
						Plaggie & \checkmark & & & & & & & \\
						SIM & \checkmark & & \checkmark & & & & & \checkmark\\
						dupl & & \checkmark & & & & & & \\
						\bottomrule
					\end{tabular}
				\end{center}
			\end{table}
		
	\section{Design}
		\subsection{Getting the tools}
			Three anti-plagiarism tools were chosen for this project. Moss was the first choice because of the number of languages it supports and its maturity. JPlag and dupl were chosen to give a variety in the algorithms used.
			
			\subsubsection{Moss}
			Moss is a web service, while JPlag and dupl can be run locally. To access Moss, one must send an email to \verb|moss@moss.stanford.edu| containing the following, with \verb|<email address>| replaced with one's actual email address:
			\begin{verbatim}
				registeruser
				mail <email address>
			\end{verbatim}
			\noindent Moss will then send a Moss upload script with a unique user ID, which should be placed in directory \verb|<x>|.
			
			\subsubsection{dupl}
			To download and install dupl, run the following command:
			\begin{lstlisting}[language=bash]
	go get -u github.com/mibk/dupl
			\end{lstlisting}
			\noindent dupl requires Go version 1.4 or higher.
			
			\subsubsection{JPlag}
			To download and install JPlag, get the code from \\\verb|https://github.com/jplag/jplag|. Maven is also required. Download and install it if necessary. Go to the \verb|jplag/jplag/jplag| directory inside the download and run the following command:
			\begin{lstlisting}[language=bash]
	mvn clean generate-sources assembly:assembly
			\end{lstlisting}
			This should create a jar file inside the \verb|./target/| directory called \\\verb|jplag-x.y.z-SNAPSHOT-jar-with-dependencies.jar| where \verb|x.y.z| is the specific version number of JPlag.
			
		\subsection{Tool commands}
			\subsubsection{Moss}
			Here is an example of a Moss command:
			\begin{lstlisting}[language=bash, breaklines=true]
./moss -l java -m 2 -d ./code/class01/student01/assignment01/*.java ./code/class01/student02/assignment01/*.java ./code/class01/student03/assignment01/*.java > assignment01.txt &
			\end{lstlisting}
			\noindent The first argument is the Moss upload script. The $-l$ flag signifies that the next argument will be the language the assignments were written in, which in this case is Java. The $-m$ flag signifies that the following argument will be the threshold for Moss, which tells Moss to ignore matches that appear in more than this number of files. In this example, if a piece of code appears in more than 2 files, it is ignored. This is useful if instructors provide some functions or classes for their students to use. The $-d$ option signifies that directories will be compared instead of specific files. In this example, all the java files from three students' assignment 1 will be compared. Moss will search inside subdirectories. Finally the output from Moss is sent to a text file. The text file will contain a URL that has the results from Moss.
			
			\subsubsection{dupl}
			Here is an example of a dupl command:
			\begin{lstlisting}[language=bash, breaklines=true]
dupl -t 15 -html ./code/class01/student01/assignment02/ ./code/class01/student02/assignment02/ ./code/class01/student03/assignment02/ > assignment02.html &
			\end{lstlisting}
			\noindent The first argument is a call to dupl. The next argument, $-t$ is dupl's threshold. This is minimum nodes that pieces of code must be before dupl declares them as a duplicates. In this example, it is 15 nodes. $-html$ specifies html output. Next is a list of the directories. dupl will search inside subdirectories. Finally the output from dupl will be sent to an html file.
			
			\subsubsection{JPlag}
			Here is an example of a JPlag command:
			\begin{lstlisting}[language=bash, breaklines=true]		
java -jar ./jplag/jplag.jar -l java17 -t 15 -r ./results/lab1 -s lab1 ./students
			\end{lstlisting}
			\noindent The first three arguments say to run a Java jar file in that location called jplag.jar. $-l$ says which language to use, which in this case is Java 1.7. $-t$ is the minimum number of tokens to match (threshold) argument. The next argument, $-r$ specifies where to save the results. $-s$ says to check all the files in subdirectories with that label. So here any Java files in subdirectories labeled lab1 will be checked. The last argument is the base directory where the code resides.		
			
		\subsection{Understanding Autograder}
			To be able to add functionality to Autograder, it was necessary to understand how it works. This meant looking through the code to see what happens when certain events occurred. For example, when the Rebuild button on the teacherresultpage.html is pressed, this calls the \verb|$("#rebuild").click()| function in the teacher.result.page.js file. The click function then posts to the /event/manualbuild URL. webserver.go handles the post by calling ManualCITriggerHandler() function in ci.go. ManualCITriggerHandler() then starts the daemon, which creates a Docker container and a set of commands to run on the docker container. The docker container pulls the students code and the test code from GitHub and proceeds to run the tests on it.	
			
		\subsection{Process}
			Since Autograder was written in Go, this project is also written in Go. Later it was decided to make this project a standalone application that Autograder will call, since another university has expressed interest in using it. The program will call each of the anti-plagiarism tools and store the results. The \verb|golint| application was run against the code for suggestions on making the code follow Go coding conventions. The \verb|go fmt| command was run to clean up the whitespace in the code. A separate Go package will be written for each anti-plagiarism tool. The packages will implement a common interface which will create the commands to send to the tools and will format the results.
			
			The anti-plagiarism application will have two main functions. The first is to call the various anti-plagiarism detection tools, and the second is to check and store the results. It can take an indefinite amount of time for the tools to complete their analysis of the students' code, so it is best for the application to run the commands for the tools as a background process by using the $\&$ symbol at the end of each command.
			
			\subsubsection{Configuration file}
			There is a configuration file located in the base directory of the anti-plagiarism project called $config.txt$. LAB\_FILES\_BASE\_DIRECTORY tells the application where to store the code pulled from GitHub. MOSS\_FULLY\_QUALIFIED\_NAME contains the fully-qualified name of the Moss script. JPLAG\_FULLY\_QUALIFIED\_NAME contains the fully-qualified name of the JPlag jar file. RESULTS\_DIRECTORY tells the application where to store the results. MOSS\_THRESHOLD is the Moss threshold described in the Tool commands subsection. DUPL\_THRESHOLD and JPLAG\_THRESHOLD contain similar values.
			
			Here is an example:
			\begin{lstlisting}
LAB_FILES_BASE_DIRECTORY=/home/autograde/repos
MOSS_FULLY_QUALIFIED_NAME=/home/autograde/moss/moss
JPLAG_FULLY_QUALIFIED_NAME=/home/autograde/go/src/
	github.com/jplag/jplag/jplag/target/jplag.jar
RESULTS_DIRECTORY=/home/autograde/results
MOSS_THRESHOLD=4
DUPL_THRESHOLD=15
JPLAG_THRESHOLD=15
			\end{lstlisting}
			
			\subsubsection{Calling the anti-plagiarism tools}
			Before calling the anti-plagiarism tools, first the students' code will be pulled from Github to the Autograder server. The directory structure will consist of a base directory containing subdirectories for each class. Inside each class, there will be directories for each student, which will have directories for each assignment. See figure \ref{fig:directories}. This is similar to how Autograder stores the files in Github, so pulling the code for the anti-plagiarism project will be simplified. Each student's work for an assignment to be compared against the other students' work for that assignment in that class. This will keep the number of files being compared from growing too large. 
			
			\begin{figure}[h!]
				\includegraphics[scale=0.75]{Directories.png}
				\caption{Directory structure.}
				\label{fig:directories}
			\end{figure}
			
			Next the commands are created for each anti-plagiarism tools based on the location of the code, the language in which the code was written, the threshold of the tool, and various other parameters.
			
			\subsubsection{Checking for and storing the results}
			
	\section{Results}
	\section{Issues}
		A few issues were encountered during the project.
		\begin{itemize}
			\item JPlag will only work with the languages it supports. Therefore JPlag will not accept Go files. 
			\item dupl will not compare files it cannot parse. So files that are submitted with syntax errors could have plagiarized code, but they will remain unnoticed.
		\end{itemize}
	\section{Analysis}
	\section{Conclusion}
	\bibliography{sources}
	\bibliographystyle{ieeetr}
\end{document}